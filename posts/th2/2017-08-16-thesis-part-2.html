<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>[thesis II] A simulation tool for scala with spatial integration: scala-flow - Ruben Fiszel's website</title>
	<link rel="icon" type="image/png" href="../../images/lambda-xl.png">
	<link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
	<link rel="stylesheet" type="text/css" href="../../sass/main.css" />
	<link type="text/css" href="../../css/font-awesome.min.css" rel="stylesheet">
	<link rel="stylesheet" href="../../css/mermaid.css">	
	<link rel="stylesheet" href="../../fonts/Serif/cmun-serif.css" />
	<link href="http://fonts.googleapis.com/css?family=Droid+Serif" rel="stylesheet" type="text/css">	  
	<link href="http://fonts.googleapis.com/css?family=Droid+Sans" rel="stylesheet" type="text/css">
	<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1//MathJax.js?config=TeX-AMS_CHTML"></script>		
    </head>
    <body>
	<div id="header">
	    <div id="logo">
		<img src="../../images/lambda.png" alt="Lambda">
		<a href="../../">Ruben Fiszel's website</a>
	    </div>

	    <div id="navigation">
		<a href="../../">Home</a>
		<a href="../../about.html">About</a>
		<a href="../../contact.html">Contact</a>
	    </div>
	    <div class="clear"></div>
	</div>

	<div id="content">
	    <h1> [thesis II] A simulation tool for scala with spatial integration: scala-flow</h1>

	    <div class="info">
    Posted on August 16, 2017
    
        by Ruben Fiszel
    
</div>
<div class="post">
  <h3 id="about">About</h3>
<p>This post is the part II out of IV of my <a href="../../assets/thesis.pdf">master thesis</a> at the <a href="http://dawn.cs.stanford.edu/">DAWN lab</a>, Stanford, under <a href="http://arsenalfc.stanford.edu/kunle">Prof. Kunle</a> and <a href="http://lampwww.epfl.ch/~odersky/">Prof. Odersky</a> supervision. The central themes of this thesis are sensor fusion and spatial, an hardware description language (Verilog is also one, but tedious).</p>
<p>This part is about scala-flow, a simulation library with a spatial-lang integration written to ease the prototyping, development and testing of applications that can be represented as data flows with some subpart going through spatial written accelerators.</p>
<h1 id="a-simulation-tool-for-data-flows-with-spatial-integration-scala-flow">A simulation tool for data flows with Spatial integration: scala-flow</h1>
<h2 id="purpose">Purpose</h2>
<p>Data flows are intuitive visual representations and abstractions of computation. As all forms of representations and abstractions, they ease complexity management, and let engineers reason at a higher level. They are common in the context of embedded systems, where sensors and electronic circuits have natural visual representations. They are also used in most forms of data processing, in particular those related to so called <em>big data</em>.</p>
<p>Spark and Simulink are popular libraries for data processing and embedded systems, respectively. Spark grew popular as an alternative to Hadoop. The advantages of Spark over Hadoop was, among others, in-memory communication between nodes (as opposed to through files) and a functionally inspired scala api that brought better abstractions and reduced the number of lines of code. Less boilerplate and duplication of code improve abstraction and ease prototyping thanks to faster iteration.</p>
<p>Simulink by MathWorks on the other hand, is a graphical programming environment for modeling, simulating and analyzing dynamic systems, including embedded systems. Its primary interface is a graphical block diagramming tool and a customizable set of block libraries.</p>
<div class="figure">
<img src="simulink.png" alt="An example of the simulink interface" />
<p class="caption">An example of the simulink interface</p>
</div>
<p>scala-flow is inspired by both of these tools. It is general purpose in the sense that it can be used to represent any dynamic systems. Nevertheless, its primary intended use is to develop, prototype, and debug embedded systems, and in particular those that make use of spatially programmed hardware. scala-flow has a functional/composable api, displays the constructed graph and provides block constructions. It has strong type safety: the type of the input and output of each node is checked during compilation time to ensure the soundness of the resulting graph.</p>
<h2 id="source-sink-and-transformations">Source, Sink and Transformations</h2>
<p>Data are passed from nodes to nodes under the form of typed “packets” containing a value of the given type, an emission timestamp, and the delays the packet has encountered during its processing through the different nodes of the graph.</p>
<p><code>case class Timestamped[A](t: Time, v: A, dt: Time)</code></p>
<p>They are called Timestamped because they represent values and their corresponding timestamp information.</p>
<p>Packets get emitted from <code>Source0[T]</code> (nodes with no input), processed and transformed by other nodes until they reach sinks (nodes with no output). Nodes are connected between each other according to the structure of the data flow.</p>
<p>Nodes all mix-in the common trait <code>Node</code>. Every emitting <code>Node</code> (all nodes except sinks) mix-in the trait <code>Source[A]</code> whose type parameter <code>A</code> indicates the type of the packets emitted by this node. Indeed, nodes can only have one output but they can have any number of inputs. Every node also mixes-in the trait <code>SourceX[A, B, ...]</code> where X is the number of inputs for that node and is replaced by the actual arity (1, 2, 3, …). This is similar to <code>FunctionX[A, B, ..., R]</code>, the type of functions in scala.</p>
<ul>
<li><code>Source0</code> indicates that the node takes exactly 0 input.</li>
<li><code>Source1[A]</code> indicates that the node has 1 input whose packets are of type A.</li>
<li><code>Source2[A,B]</code> indicates that the nodes has 2 inputs whose packets are respectively of type <code>A</code> and <code>B</code></li>
<li>etc …</li>
</ul>
<p>Since all nodes mix-in a <code>SourceX</code>, the compiler can check that the inputs of each node are of the right type.</p>
<p>All <code>SourceX</code> must define <code>def listenI(x: A)</code> where <code>I</code> goes from 1 to X and <code>A</code> correspond to the corresponding type parameter of <code>SourceX</code>. <code>def listenI(x: A)</code> defines the action to take whenever a packet is received from the input I. Those functions are callbacks used to pass packets to the nodes following a listener pattern.</p>
<p>There is a special case, <code>SourceN[A, R]</code> which represent nodes that have an *-arity of type <code>A</code> and emit packets of type <code>R</code>. For instance, the <code>Plot</code> nodes take * number of sources and display them all on the same plot. The only constraint is that all the source nodes must emit the same kind of data of type A. Otherwise, it would not make sense to compare them. For plots specifically, <code>A</code> also has a context bound of <code>Data</code> which means that there exists a conversion from <code>A</code> to a <code>Seq[Float]</code>, to ensure that <code>A</code> is displayable in a multiplot as time series. The x-axis, the time, correspond to the timestamp of emission contained in the packet.</p>
<p>An intermediary node that applies a transformation mixs-in the trait <code>OpX[A, B, ..., R]</code> where <code>A, B</code> is the type of the input, and <code>R</code> is the type of the output.</p>
<p><code>OpX[A, B, ..., R] extends SourceX[A, B, ...] with Source[R]</code>.</p>
<p>For instance, <code>zip(sourceA, sourceB)</code> is an <code>Op[A, B, (A, B)]</code>. In most cases, <code>Op</code>s are a transformation of an incoming packet followed by a broadcasting (with the function <code>def broadcast(x: R)</code>) to the nodes that have for source this node.</p>
<h2 id="demo">Demo</h2>
<p>Below is the scala-flow code corresponding to a data-flow comparing a particle filter, an extended kalman filter, and the true state of the underlying model, the trajectory of the drone. At each tick of the different clocks, a packet containing the time as value is sent to a node simulating a sensor. Those sensors have access to the underlying model and transform the time into noisy sensor measurements, then forward them to the two filters. Once processed by the filters, the packets are plotted by the Plot sink. The plot also take as input the true state as given by the “toPoints” transformation.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">
  <span class="co">//****** Model ******</span>
  <span class="kw">val</span> dtIMU   = <span class="fl">0.01</span>
  <span class="kw">val</span> dtVicon = (dtIMU * <span class="dv">5</span>)

  <span class="kw">val</span> covAcc    = <span class="fl">1.0</span> 
  <span class="kw">val</span> covGyro   = <span class="fl">1.0</span> 
  <span class="kw">val</span> covViconP = <span class="fl">0.1</span> 
  <span class="kw">val</span> covViconQ = <span class="fl">0.1</span>

  <span class="kw">val</span> numberParticles = <span class="dv">1200</span>

  <span class="kw">val</span> clockIMU   = <span class="kw">new</span> <span class="fu">TrajectoryClock</span>(dtIMU)
  <span class="kw">val</span> clockVicon = <span class="kw">new</span> <span class="fu">TrajectoryClock</span>(dtVicon)

  <span class="kw">val</span> imu   = clockIMU.<span class="fu">map</span>(<span class="fu">IMU</span>(<span class="fu">eye</span>(<span class="dv">3</span>) * covAcc, <span class="fu">eye</span>(<span class="dv">3</span>) * covGyro, dtIMU))
  <span class="kw">val</span> vicon = clockVicon.<span class="fu">map</span>(<span class="fu">Vicon</span>(<span class="fu">eye</span>(<span class="dv">3</span>) * covViconP, <span class="fu">eye</span>(<span class="dv">3</span>) * covViconQ))

  <span class="kw">lazy</span> <span class="kw">val</span> pfilter = 
      <span class="fu">ParticleFilterVicon</span>(
        imu,
        vicon,
        numberParticles,
        covAcc,
        covGyro,
        covViconP,
        covViconQ
      )

  <span class="kw">lazy</span> <span class="kw">val</span> ekfilter = 
      <span class="fu">EKFVicon</span>(
        imu,
        vicon,
        covAcc,
        covGyro,
        covViconP,
        covViconQ
      )

  <span class="kw">val</span> filters = List(ekfilter, pfilter)

  <span class="kw">val</span> points = clockIMU.<span class="fu">map</span>(<span class="fu">LambdaWithModel</span>(
	(t: Time, traj: Trajectory) =&gt; traj.<span class="fu">getPoint</span>(t)), <span class="st">&quot;toPoints&quot;</span>)

  <span class="kw">val</span> pqs =  points.<span class="fu">map</span>(x =&gt; (x.<span class="fu">p</span>, x.<span class="fu">q</span>), <span class="st">&quot;toPandQ&quot;</span>)

  <span class="fu">Plot</span>(pqs, filters:_*)</code></pre></div>
<div class="figure">
<img src="empty.jpg" alt="Example of a scala-flow program" />
<p class="caption">Example of a scala-flow program</p>
</div>
<pre class="text" samepage="true"><code>         ┌────────────────────┐ ┌────────────────────┐
         │TrajectoryClock 0.01│ │TrajectoryClock 0.05│
         └─────┬────────────┬─┘ └────────┬───────────┘
               │            │            │            
               v            v            v            
           ┌───────┐   ┌────────┐   ┌─────────┐       
           │Map IMU│   │toPoints│   │Map Vicon│       
           └──┬──┬─┘   └────┬───┘   └───┬──┬──┘       
              │  │          │           │  │          
              │  │          │    ┌──────┘  │          
              │  └──────────┼────┼─────────┼┐         
              └───────────┐ │    │         ││         
             ┌────────────┼─┘    │         ││         
             │            │      │         ││         
             v            v      v         vv         
         ┌───────┐ ┌───────────────────┐ ┌────────┐   
         │toPandQ│ │     RBPFVicon     │ │EKFVicon│   
         └───┬───┘ └──────────┬────────┘ └────┬───┘   
             │                │               │       
             └──────────────┐ │ ┌─────────────┘       
                            │ │ │                     
                            v v v                     
                          ┌───────┐                   
                          │ Plot  │                   
                          └───────┘                  </code></pre>
<div class="figure">
<img src="empty.jpg" alt="Graph representation of the data-flow" />
<p class="caption">Graph representation of the data-flow</p>
</div>
<h2 id="block">Block</h2>
<p>A block is a node representing a group of nodes. That node can be summarized by its input and output such that from an external perspective, it can be considered as a simple node. Similar to the way an interface or an API hide its implementation details, a block hides its inner workings to the rest of the data-flow as long as the block receives and emits the right type of packets. This logic extends to the graphical representation. Blocks are represented as nodes in the high-level graph but expanded in an independent graph below the main one.</p>
<p>Similar to <code>OpX[A, B, ..., R]</code> , there exists <code>BlockX[A, B, ..., R]</code> which all extend <code>Block[R]</code> and take X sources as input. All <code>Block[R]</code> must define an <code>out</code> method of the form: <code>def out: Source[R]</code>.</p>
<p>For instance, the filters are blocks with the following signatures:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">RBPFVicon</span>(rawSource1: Source[(Acceleration, Omega)],
                     rawSource2: Source[(Position, Attitude)],
                     N: Int,
                     covAcc: Real,
                     covGyro: Real,
                     covViconP: Real,
                     covViconQ: Real)	
	<span class="kw">extends</span> Block2[(Acceleration, Omega), 
		           (Position, Attitude),
				   (Position, Attitude)] {
	
		<span class="kw">def</span> imu = source1
		<span class="kw">def</span> vicon = source2
		
		<span class="kw">def</span> out = ...
	}</code></pre></div>
<div class="figure">
<img src="empty.jpg" alt="Signature of the block of the particle filter" />
<p class="caption">Signature of the block of the particle filter</p>
</div>
<p>and similar for EKFVicon.</p>
<p>The careful reader might notice that the above block takes as arguments <code>rawSourceI</code> and not <code>sourceI</code> directly. However, the packets are processing in the body of the class as incoming from <code>sourceI</code> (<code>def imu = source1</code>). This is a consequence of intermediary <code>Source</code> potentially needing to be generated during the graph creation to synchronize multiple scheduler together. More details below.</p>
<h2 id="graph-construction">Graph construction</h2>
<p>A graph can be entirely re-evaluated multiple times. For instance, we might want to run our simulation more than once. A feature of scala-flow is that the nodes of a graph are immutable and can be reused between different evaluations. This enables us to serialize, store or transfer a graph easily. A graph is a data structure and scala-flow follows that intuition by separating the construction of graph and its evaluations. What is specific and shortlived for the lapse of time of an evaluation of a graph are the <code>Channel</code>s between the different nodes.</p>
<h3 id="channel">Channel</h3>
<p><code>Channel</code>s are specific to a particular node and a particular “channel” of a node. A “channel” here refers to the actual I from <code>listenI(packet)</code> of a node to call. When the graph is initialized, the channels are created according to the graph structure.</p>
<p>If we take a look at <code>Channel2</code> for instance:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Channel[A] {
  <span class="kw">def</span> <span class="fu">push</span>(x: Timestamped[A], dt: Time): Unit
}

...

<span class="kw">case</span> <span class="kw">class</span> Channel2[A](receiver: Source2[_, A], scheduler: Scheduler)
    <span class="kw">extends</span> Channel[A] {
  <span class="kw">def</span> <span class="fu">push</span>(x: Timestamped[A], dt: Time = <span class="dv">0</span>) = 
	...
}</code></pre></div>
<p>We see that it requires that the receiver is a <code>Source2</code>. This actually means that the receiver must have <strong>at least</strong> (and not exactly) 2 sources. This is a consequence of<code>SourceI+1</code> extending <code>SourceI</code>, the base case being <code>Source0</code>: <code>trait Source2[A, B] extends Source1[A]</code>.</p>
<p>Now, if we look at the private method <code>broadcast</code> inside <code>Source[T]</code></p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">broadcast</span>(x: =&gt; Timestamped[A], t: Time = <span class="dv">0</span>) =
    <span class="kw">if</span> (!closed)
      channels.<span class="fu">foreach</span>(_.<span class="fu">push</span>(x, t))</code></pre></div>
<p>We see that <code>broadcast</code> is simply pushing elements into all its private channels. The channels are set during initialization of the graph in a simple manner: The graph is traversed and for all node the corresponding channel are created for its corresponding sources.</p>
<h2 id="buffer-and-cycles">Buffer and cycles</h2>
<p>It is possible to create cycles inside data-flows at the express condition that the immediate node creating a cycle is exclusively a kind of node called <code>Buffer</code>. Buffers relay to the next node any incoming data but with the particularity of a buffering of one packet. <code>Buffer</code>s are created with an initial value. When the first packet arrives, the Buffer stores the incoming packet and broadcast the initial value. When another following packet arrives, the buffer stores the new packet and broadcast the previously stored one and so on.</p>
<p>Even using buffer nodes, declaring cycle requires additional steps:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> source: Source[A] = ...
<span class="kw">val</span> buffer = Buffer(merge, initA)
<span class="kw">val</span> zipped = source.<span class="fu">zip</span>(buffer)</code></pre></div>
<p>This will not be valid scala because there is a circular dependency between buffer and zipped. Indeed, instantiating <code>buffer</code> require to instantiate <code>zipped</code>, which require to instantiate <code>buffer</code> … A solution is to use <code>lazy val</code>.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> source: Source[A] = ...
<span class="kw">lazy</span> <span class="kw">val</span> buffer = Buffer(merge, initA)
<span class="kw">lazy</span> <span class="kw">val</span> zipped = source.<span class="fu">zip</span>(buffer)</code></pre></div>
<p><code>lazy val a = e</code> in scala implements lazy evaluation, meaning the expression <code>e</code> is not evaluated until it is needed. In our case, this makes sure that both <code>buffer</code> and <code>zipped</code> can be declared and instantiated. It is enough that their parameters are declared of the right type, they do not actually need to evaluated. At the initialization of the entire graph, there is no circular dependency either because both instances exist and will only be used during the evaluation of the graph.</p>
<h2 id="source-api">Source API</h2>
<p>Here is a simplified description of the API of each source.</p>
<p>When relevant, the functions have an alternative <code>methodNameT</code> function that takes themselves function whose domain is <code>Timestamped[A]</code> instead of <code>A</code>.</p>
<p>For instance, there is a</p>
<p><code>def foreachT(f: Timestamped[A] =&gt; Unit): Source[A]</code></p>
<p>which is equivalent to the <code>foreach</code> below except it can access the additional fields <code>t</code> and <code>dt</code> in <code>Timestamped</code></p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">
<span class="kw">trait</span> Source[A] {

  <span class="co">/** return a new source that map every incoming packet by the function f </span>
<span class="co">    * such that new packets are Timestamped[B] </span>
<span class="co">    */</span>
  <span class="kw">def</span> map[B](f: A =&gt; B): Source[B]

  <span class="co">/** return a filtered source that only broadcast</span>
<span class="co">    *  the elements that satisfy the predicate b */</span>
  <span class="kw">def</span> <span class="fu">filter</span>(b: A =&gt; Boolean): Source[A]

  <span class="co">/** return this source and apply the function f to each</span>
<span class="co">    *  incoming packets as soon as they are received </span>
<span class="co">    */</span>
  <span class="kw">def</span> <span class="fu">foreach</span>(f: A =&gt; Unit): Source[A]
  
  <span class="co">/** return a new source that broadcast elements</span>
<span class="co">    * until the first time the predicate b is not satisfied</span>
<span class="co">    */</span>
  <span class="kw">def</span> <span class="fu">takeWhile</span>(b: A =&gt; Boolean): Source[A]  
  
  <span class="co">/** return a new source that accumulate As into a List[A]</span>
<span class="co">    * then broadcast it when the next packet from the other </span>
<span class="co">    * source clock is received </span>
<span class="co">    */</span>
  <span class="kw">def</span> <span class="fu">accumulate</span>(clock: Source[Time]): Source[ListT[A]]
    
  <span class="co">/** return a new source that broadcast all element inside the collection</span>
<span class="co">    * returned by the application of f to all incoming packet</span>
<span class="co">    */</span>
  <span class="kw">def</span> flatMap[C](f: A =&gt; List[C]): Source[C]
 
  <span class="co">/** assumes that A is a List[Timestamped[B]]. </span>
<span class="co">    * returns a new source that apply the reduce function </span>
<span class="co">    * over the collection contained in every incoming packet */</span>
  <span class="kw">def</span> reduce[B](default: B, f: (B, B) =&gt; B)
      (<span class="kw">implicit</span> ev: A &lt;:&lt; ListT[B]): Source[B]
	  
  <span class="co">/** return a new source that broadcast pair of the packet from this source </span>
<span class="co">    * and the source provided as argument. Wait until a packet is received </span>
<span class="co">    * from both source. Packets from both source are queued such </span>
<span class="co">    * that independant of the order, they are never discarded</span>
<span class="co">    * A2 B1 A3 B2 B3 B4 B5 A4=&gt; (A1, B1), (A2, B2), (A3, B3), (A4, B4),</span>
<span class="co">	* [Queue[B5]]</span>
<span class="co">    */</span>
  <span class="kw">def</span> zip[B](s2: Source[B]): Source[Boolean]


  <span class="co">/** return a new source that broadcast pair of the packet from this source </span>
<span class="co">    * and the source provided as argument. Similar to zip except that </span>
<span class="co">	* if multiple packets from the source provided as argument is received</span>
<span class="co">	* before, all except the last get discarded.</span>
<span class="co">    * A2 B1 A3 B2 B3 B4 B5 A4=&gt; (A1, B1), (A2, B2), (A3, B3), (A4, B4),</span>
<span class="co">	* [Queue[B5]]</span>
<span class="co">    */</span>
  <span class="kw">def</span> zipLastRight[B](s2: Source[B])

  
  <span class="co">/** return a new source that broadcast pair of the packet from this source </span>
<span class="co">    * and the source provided as argument. Similar to zip except that all </span>
<span class="co">	* packet except the last get discarded when both source are not in sync.</span>
<span class="co">    * A1 A2 B1 A3 B2 B3 A4=&gt; (A1, B1), (A3, B2), (B3, A4)</span>
<span class="co">    */</span>  
  <span class="kw">def</span> zipLast[B](s2: Source[B])

  <span class="co">/** return a new source that combine this source and the provided source .</span>
<span class="co">    * packets from this source are Left</span>
<span class="co">    * packets from the other source are Right</span>
<span class="co">    */</span>
  <span class="kw">def</span> merge[B](s2: Source[B]): Source[Either[A, B]]
  
  <span class="co">/** return a new source that fuse this source and the provided source</span>
<span class="co">    * as long they have the same type.</span>
<span class="co">    * any outgoing packet is indistinguishable of origin</span>
<span class="co">    */</span>  
  <span class="kw">def</span> <span class="fu">fusion</span>(sources: Source[A]*): Source[A]	  

  <span class="co">/** &quot;label&quot; every packet by the group returned by f */</span>  
  <span class="kw">def</span> groupBy[B](f: A =&gt; B): Source[(B, A)]

  <span class="co">/** print every incoming packet */</span>
  <span class="kw">def</span> <span class="fu">debug</span>(): Source[A]

  <span class="co">/** return a new source that buffer 1 element and </span>
<span class="co">    * broadcast the buffered element with the time of the incoming A </span>
<span class="co">    */</span>
  <span class="kw">def</span> <span class="fu">bufferWithTime</span>(init: A): Source[A] 
  
  <span class="co">/** return a new source that do NOT broadcast any element */</span>
  <span class="kw">def</span> muted: Source[A]

  <span class="co">/** return a new source that broadcast one incoming packet every </span>
<span class="co">    * n incoming packet.</span>
<span class="co">    * The first broadcasted packet is the nth received one</span>
<span class="co">    */</span>
  <span class="kw">def</span> <span class="fu">divider</span>(n: Int): Source[A]

  <span class="co">/** return a pair of source from a source of pair */</span>
  <span class="kw">def</span> unzip2[B, C](<span class="kw">implicit</span> ev: A &lt;:&lt; (B, C)): (Source[B], Source[C])
  
  <span class="co">/** return a new source whose every outgoing packet have an added dt</span>
<span class="co">    * in their delay component</span>
<span class="co">    */</span>
  <span class="kw">def</span> <span class="fu">latency</span>(dt: Time): Source[A]

  <span class="co">/** return a new source whose broadcasted packets contain the time of </span>
<span class="co">    * emission</span>
<span class="co">    */</span>
  <span class="kw">def</span> toTime: Source[Time]

  <span class="co">/** return a new source that do NOT broadcast the first n packets */</span>
  <span class="kw">def</span> <span class="fu">drop</span>(n: Int): Source[A]
}


<span class="kw">implicit</span> <span class="kw">class</span> <span class="fu">TimeSource</span>(source: Source[Time]) {

  <span class="co">/** stop the broadcasting after the timeframe tf has elapsed */</span>
  <span class="kw">def</span> <span class="fu">stop</span>(tf: Timeframe): Source[Time]

  <span class="co">/** add a random delay following a gaussian with corresponding </span>
<span class="co">    * mean and variance */</span>
  <span class="kw">def</span> <span class="fu">latencyVariance</span>(mean: Real, variance: Real): Source[Time]

  <span class="co">/** add a delay of dt */</span>
  <span class="kw">def</span> <span class="fu">latency</span>(dt: Time): Source[Time]

  <span class="co">/** return a new source of the difference of time between </span>
<span class="co">    * the two last emitted packets */</span>
  <span class="kw">def</span> <span class="fu">deltaTime</span>(init: Time = <span class="fl">0.0</span>): Source[Time]
  
}</code></pre></div>
<div class="figure">
<img src="empty.jpg" alt="API of the Sources" />
<p class="caption">API of the Sources</p>
</div>
<p>The real API also includes <code>name</code> and <code>silent</code> parameters. Both are only relevant for the graphical representation. The name of the block will be overriden by name if present and the node will be skipped in the graphical representation if silent is present.</p>
<h2 id="batteries">Batteries</h2>
<p>The following nodes are already included and pre-defined:</p>
<ul>
<li><code>Clock</code>: <code>Source0[Time]</code> that takes as parameter a timeframe <code>dt</code> which corresponds to the lapse of time between each emission of packets. The packets contain as values the time of emission.</li>
<li><p><code>TestTS</code>: “Test Time Series” Sink that takes a source of labeled data. Labeled data are data joined with their corresponding label. This sink displays the mean error, the max error error across all datapoints and also the RMSE.</p>
<pre class="text"><code>[info ParticleFi ] RMSE       : 1.099241e-01, 4.213478e-03
[info ParticleFi ] Mean errors: 3.026816e-01, 4.746430e-02
[info ParticleFi ] Max  errors: 7.086643e-01, 2.386466e-01</code></pre></li>
<li><p><code>Plot</code>: Sink that displays the time series under the form of a plot. Can take an arbitrary number of time series, each of arbitrary dimension. In the example below, 5 time series of 2 dimensions are plotted. The plotting library is the one included in <a href="https://github.com/scalanlp/breeze">scala-breeze</a>, used elsewhere for matrix and vector operations.</p></li>
</ul>
<div class="figure">
<img src="ex-plot.png" alt="Example of a plot generated by the Plot sink" />
<p class="caption">Example of a plot generated by the Plot sink</p>
</div>
<ul>
<li><code>Jzy3dTrajectoryVisualisation</code>: Sink. It displays a point following a trajectory in a new window. takes a source of points as source. An example as shown in Part I.</li>
</ul>
<video autoplay loop>
<source src="flight.webm" type="video/webm">
</video>
<div class="figure">
<embed src="flight.webm" width="400" />
<p class="caption">Example of a trajectory visualization</p>
</div>
<p>In addition, any <code>scala.Stream[A]</code> can be transformed into a <code>Source0</code> node using <code>EmitterStream[A]</code> with <code>A</code> being the type of the <code>Stream</code>. This is how <code>Clock</code> is implemented, as an infinite scala stream of Time.</p>
<h2 id="batch">Batch</h2>
<p>A batch is a node that processes its inputs in “batch” mode. All the other nodes process their inputs in “stream” mode. By “stream” mode, it is meant that the node processes the inputs one-by-one, as soon as they arrive. On the other hand, the “batch” mode means that the node processes the incoming packets once they have all arrived, once and for all. This is the case for most sinks (for example, it makes more sense for a plot to build it once all the data is arrived).</p>
<p>Spatial is a language described in part IV and developed to write high-level hardware design of accelerators. A spatial application can be integrated into scala-flow as a transformation node using the streaming interface of Spatial. Spatial applications can only run during the same runtime than scala-flow using the interpreter described in Part III and originally developed for this exact purpose. Batches are essential to Spatial integration: the nodes that simulate a Spatial application can only run and treat all the data at once. Indeed, running a Spatial application involves running the Spatial compiler in the background and compiling the full meta-program, including all meta-constant values.</p>
<h2 id="scheduler">Scheduler</h2>
<p>Scheduling is the core mechanism of scala-flow. Scheduling ensures that packets get emitted by the sending nodes and received by the recipient nodes at the “right time”. Since scala-flow is a simulation tool, the “scala-flow time” does not correspond at all to the real time. Scheduling emits the packets as fast as it can. Therefore, since time is an arbitrary component of the packet, the only constraint that scheduling must satisfy is emitting the packets from all nodes in the right order.</p>
<p>Scheduling is achieved by one or many Schedulers. Schedulers are essentially priority queues of actions. The priority is the timestamp plus the accumulated delay of the packet. The actions are side-effect functions that emit packets to the right node by the intermediary of channels. Every node has a scheduler and enqueue action to it every time the <code>broadcast</code> method is called. The scheduler are propagated through the graph through two rules:</p>
<ul>
<li>Every <code>Source0</code> has for <code>Scheduler</code> the “main scheduler” available globally passed on as an implicit parameter</li>
<li>Other nodes either explicitly create their own scheduler (like the batch nodes) or use the Scheduler from their <code>source1</code> input.</li>
</ul>
<p>Only one scheduler executes actions at the same time. When a scheduler is finished, another one is started unless it was the last one. In practice, when a scheduler has no more packets to handle, there is a callback to <code>CloseListener</code> nodes and scheduler according to their <code>CloseListener</code> priority. Batches have their own scheduler and are also among <code>CloseListener</code> of the <code>Scheduler</code> of their source node, waiting for them to all finish. Batches process the accumulated packets as soon as the <code>CloseListener</code> callback is called.</p>
<p>All schedulers start at time 0. The current time of a scheduler is the time of the last emitted packet. <code>Scheduler</code> can en-queue new actions while the scheduler is “live” but the en-queued packet can only have a time of emission greater or equal to the current time. In the trivial case where there is no Batch, only one scheduler is needed.</p>
<h2 id="replay">Replay</h2>
<p><code>Replay</code> are nodes at the frontier of two schedulers. They accumulate packets from the actions of the first scheduler until they receive its <code>CloseListener</code> callback. When received, they en-queue all the accumulated actions into the second scheduler. <code>Replay</code>s are the primary mechanisms of synchronization between two <code>Scheduler</code>s. A <code>Batch</code> is essentially a <code>Replay</code> with its own <code>Scheduler</code> as secondary <code>Scheduler</code>. However, a batch transforms the data before broadcasting instead of simply replaying it.</p>
<p><strong>All sources of a node must share the same scheduler. Replays are automatically inserted to ensure that this rule is respected</strong></p>
<p>The automatic insertion is the reason why nodes must define all <code>rawSourceI</code> but one should only externally ever use the <code>sourceI</code> methods. In most case, <code>rawSourceI</code> and <code>sourceI</code> are by definition the same. However, if a replay node has to be created, it is inserted in-between <code>rawSourceI</code> and <code>sourceI</code>.</p>
<h2 id="multi-scheduler-graph">Multi-Scheduler graph</h2>
<p>When the graph involves multiple schedulers, depending on the graph structure, the synchronization between them might require additional replays.</p>
<div>
<!-- htmlmin:ignore -->
<div class="mermaid">
graph LR
  subgraph scheduler 1
  sA(sourceA)
  sB(sourceB)
  sC(sourceC)	
  end
  subgraph scheduler2
  node(Node)
  rest(...)
  end
  sA--&gt;node
  sB--&gt;node
  sC--&gt;node
  node--&gt;rest
</div>
<!-- htmlmin:ignore -->
</div>
<div class="figure">
<img src="empty.jpg" alt="Node’s sources sharing the same Scheduler" />
<p class="caption">Node’s sources sharing the same Scheduler</p>
</div>
<p>In the above structure, no replay need to be created because all sources of the node “Node” share the same scheduler. It suffices to wait for the closing callback of that scheduler.</p>
<div>
<!-- htmlmin:ignore -->
<div class="mermaid">
graph LR
  subgraph scheduler 1
  sA(sourceA)
  end
  subgraph scheduler 2
  sB(sourceB)
  end
  subgraph scheduler 3	
  sC(sourceC)	
  end
  subgraph scheduler 4
  node(Node)
  rest(...)
  end
  sA--&gt;node
  sB--&gt;node
  sC--&gt;node
  node--&gt;rest
</div>
<!-- htmlmin:ignore -->
</div>
<div class="figure">
<img src="empty.jpg" alt="Node’s sources not sharing the same Scheduler" />
<p class="caption">Node’s sources not sharing the same Scheduler</p>
</div>
<p>In the above structure, intermediary replays must be created so that the node “Node” sources share the same scheduler.</p>
<div>
<!-- htmlmin:ignore -->
<div class="mermaid">
graph LR
  subgraph scheduler 1
  sA(sourceA)
  end
  subgraph scheduler 2
  sB(sourceB)
  end
  subgraph scheduler 3	
  sC(sourceC)	
  end
  subgraph scheduler 4
  replay1(Replay1)
  replay2(Replay2)
  replay3(Replay3)
  end	
  subgraph scheduler 5
  node(Node)
  rest(...)
  end
  sA--&gt;replay1
  sB--&gt;replay2
  sC--&gt;replay3
  replay1--&gt;node
  replay2--&gt;node
  replay3--&gt;node	
  node--&gt;rest
</div>
<!-- htmlmin:ignore -->
</div>
<div class="figure">
<img src="empty.jpg" alt="Example of Replays between inserted in-between a Node and its sources" />
<p class="caption">Example of Replays between inserted in-between a Node and its sources</p>
</div>
<h2 id="inithook">InitHook</h2>
<p>Some nodes need initialization values for each simulation evaluation. For instance, this is the case for the trajectory filters: the filters require to be given the initial position and attitude of the drone. An <code>InitHook[I]</code> is an implicit parameter passed to the nodes during their declaration. The type parameter <code>I</code> is the type of the values that will be accessible by the nodes as initialization values.</p>
<h2 id="modelhook">ModelHook</h2>
<p>Similarly, some nodes need access to a “Model”. A “Model” is specific to a simulation and is an oracle that a node might need to consult in order to generate data or get any other information about the external simulation environment. For instance, the sensor nodes generate noisy measurements as a function of the time based on the underlying trajectory model. Similar to <code>InitHook[I]</code>, it is passed to nodes during the graph declaration as an implicit parameter.</p>
<h2 id="nodehook">NodeHook</h2>
<p>To gather the nodes and their connection between each others, a <code>NodeHook</code> is used. Every node must have access to a <code>NodeHook</code> to add itself to the registry. For nodes that take no input, the <code>Source0</code>, the <code>NodeHook</code> is passed as an implicit parameter. For any other nodes, the <code>NodeHook</code> is propagated through the graph. All others nodes use the <code>NodeHook</code> from their <code>source1</code>. This is similar to the way <code>Scheduler</code> are propagated through the graph.</p>
<h2 id="graphical-representation">Graphical representation</h2>
<p>The graphical representation is a graph in the <code>ASCII</code> format. The library <a href="https://github.com/mdr/ascii-graphs">ascii-graphs</a> is used to generate the output in <code>ASCII</code> from sets of vertices and edges. The set of vertices and edges is retrieved from the set of nodes contained in <code>NodeHook</code> and their sources.</p>
<h2 id="flowapp">FlowApp</h2>
<p>A <code>FlowApp[M, I]</code> is an extension of the scala <code>App</code>, a trait that treats the inner declaration of an object as a main program function. Its type parameters correspond respectively to the type parameter of <code>ModelHook[M]</code> and <code>InitHook[I]</code>. A <code>FlowApp</code> has the methods <code>drawExpandedGraph()</code> which display the <code>ASCII</code> representation of the graph and the method <code>run(model, init)</code> which run the evaluation of the simulation with the given model and initialization value.</p>
<h2 id="spatial-integration">Spatial integration</h2>
<p>Scala-flow can also be used as a complementary tool for the development of applications embedding Spatial, a language to design hardware accelerators. Accelerators can be easily represented as simple transformation nodes in a data flow and hence as a regular <code>OpX</code> node in scala-flow.</p>
<p><code>SpatialBatch</code> and its variants are the nodes used to embed spatial applications. <code>SpatialBatchRawX</code>s run a user-defined application. The application can use the list of incoming packets as a constant list of values. X is the number of sources of the node. <code>SpatialBatchX</code>s are specialized <code>SpatialBatchRawX</code>s with additional syntactic sugar such that there is no more boilerplate and the required code is reduced to the most essential to write stream processing Spatial applications. It is only to define a function <code>def spatial(x: TSA): SR</code> where <code>TSA</code> is a struct containing a value <code>v</code> of type <code>SA</code> (see below) and the packet timestamp as <code>t</code>.</p>
<p>If we take a look at <code>SpatialBatch1</code>’s signature,</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> SpatialBatch1[A, R, SA: Bits: Type, SR: Bits: Type]
	(<span class="kw">val</span> rawSource1: Source[A])
	(<span class="kw">implicit</span> <span class="kw">val</span> sa: Spatialable[A] { <span class="kw">type</span> Spatial = SA },
			  <span class="kw">val</span> sr: Spatialable[R] { <span class="kw">type</span> Spatial = SR }
	)</code></pre></div>
<p>we see that it takes type parameter <code>A, R, SA, SR</code> and the typeclass instances of <code>Spatialable</code> for <code>SA</code> and <code>SR</code>. <code>A</code> and <code>R</code> are the type members representing respectively the incoming and outgoing packet type. <code>SA</code> and <code>SR</code> are the spatial type into what they are converted to such that they can be handled by a spatial DSL. Indeed, <code>scala.Double</code> and <code>spatial.Double</code> are not the same type. The latter is a staged type part of the spatial DSL.</p>
<p><code>Spatialable[A]</code> is a typeclass that declare a conversion from <code>A</code> to a Spatial type (declared as the inner type member <code>Spatial</code> of <code>Spatialable</code>.</p>
<p>There exists a <code>Spatialable[Time]</code> which make the following example possible:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">val</span> clock1 = <span class="kw">new</span> <span class="fu">Clock</span>(<span class="fl">0.1</span>).<span class="fu">stop</span>(<span class="dv">10</span>)
  <span class="kw">val</span> clock2 = <span class="kw">new</span> <span class="fu">Clock</span>(<span class="fl">0.1</span>).<span class="fu">stop</span>(<span class="dv">10</span>)  

  <span class="kw">val</span> spatial = <span class="kw">new</span> SpatialBatch1[Time, Time, Double, Double](clock1) {
    <span class="kw">def</span> <span class="fu">spatial</span>(x: TSA) = {
      <span class="fu">cos</span>(x.<span class="fu">v</span>)
    }    
  }

  <span class="kw">val</span> spatial2 = <span class="kw">new</span> SpatialBatch1[Time, Time, Double, Double](clock2) {
    <span class="kw">def</span> <span class="fu">spatial</span>(x: TSA) = {
      x.<span class="fu">v</span> + <span class="dv">42</span>
    }    
  }


  <span class="kw">val</span> spatial3 = <span class="kw">new</span> SpatialBatch2[Time, Time, Time, Double, Double, Double]
	                              (spatial, spatial2) {
    <span class="kw">def</span> <span class="fu">spatial</span>(x: Either[TSA, TSB]) = {
      x <span class="kw">match</span> {
        <span class="kw">case</span> <span class="fu">Right</span>(t) =&gt; t.<span class="fu">v</span><span class="dv">+10</span>
        <span class="kw">case</span> <span class="fu">Left</span>(t) =&gt; t.<span class="fu">v</span><span class="dv">-10</span>
      }
    }    
  }

  <span class="fu">Plot</span>(spatial3)</code></pre></div>
<div class="figure">
<img src="empty.jpg" alt="Usage demonstration of spatial batches" />
<p class="caption">Usage demonstration of spatial batches</p>
</div>
<p>Even though it looks inconspicuous, the <code>cos</code>, <code>+</code>, <code>-</code> functions are actually functions from the Spatial DSL. This simple scala-flow program actually compiles and runs through the interpreter 3 different Spatial programs.</p>
<p>The development of an interpreter was required so that Spatial applications could run on the same runtime than scala-flow. The interpreter development is detailed in the next part of this thesis.</p>
<h2 id="conclusion">Conclusion</h2>
<p><code>scala-flow</code> is a modern framework to simulate, develop, prototype and debug applications which have a natural representation as data-flows. Its integration with Spatial makes it a good tool to include with Spatial to ease the development complex applications whenever the accelerated application needs to be written over multiple iterations of increasing complexity, and tested on different scenarios with modelable environments.</p>
<div id="refs" class="references">

</div>
</div>
<div class="license" style="margin-left:80%;">
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="../../images/cc.png" /></a>
</div>

	</div>

	<hr>

	<div id="footer">
	    <section class="social">
		<a href="https://ch.linkedin.com/in/rubenfiszel" target="_blank"><i class="fa fa-linkedin fa-2x"></i></a>
		<a href="https://github.com/rubenfiszel" target="_blank"><i class="fa fa-github fa-2x"></i></a>
		<a href="mailto:ruben.fiszel@epfl.ch"><i class="fa fa-envelope fa-2x"></i></a>
		<a href="assets/RubenFiszel_resume.pdf"><i class="fa fa-file fa-2x"></i></a>
	    </section>
	</div>

	<script src="../../js/mermaid.min.js"></script>
	<script>mermaid.initialize({startOnLoad:true});</script>		
	
	<script>
	 (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
				  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	 })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

	 ga('create', 'UA-3040887-4', 'auto');
	 ga('send', 'pageview');

	</script>
    </body>
</html>
