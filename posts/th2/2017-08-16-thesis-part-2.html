<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>(thesis 2/4) A simulation tool for scala with spatial integration: scala-flow - Ruben Fiszel's website</title>
  <link rel="icon" type="image/png" href="../../images/lambda-xl.png">
  <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
  <link rel="stylesheet" type="text/css" href="../../sass/main.css" />
  <link type="text/css" href="../../css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="../../css/mermaid.css">
  <link rel="stylesheet" href="../../fonts/Serif/cmun-serif.css" />
  <link href="http://fonts.googleapis.com/css?family=Droid+Serif" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=Droid+Sans" rel="stylesheet" type="text/css">
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1//MathJax.js?config=TeX-AMS_CHTML"></script>
</head>

<body>
  <div id="header">
    <div id="logo">
      <img src="../../images/lambda.png" alt="Lambda">
      <a href="../../">Ruben Fiszel's website</a>
    </div>

    <div id="navigation">
      <a href="../../">Home</a>
      <a href="../../about.html">About</a>
      <a href="../../contact.html">Contact</a>
    </div>
    <div class="clear"></div>
  </div>

  <div id="content">
    <h1 class="post-title"> (thesis 2/4) A simulation tool for scala with spatial integration: scala-flow</h1>
    <h2 class="post-title"> </h2>

    <div class="info">
      Posted on August 16, 2017

      by Ruben Fiszel

    </div>
    <div class="post">
      <h3 id="about">About</h3>
      <p>This post is the part II out of IV of my <a href="../../assets/thesis.pdf">master thesis</a> at the <a
          href="http://dawn.cs.stanford.edu/">DAWN lab</a>, Stanford, under <a
          href="http://arsenalfc.stanford.edu/kunle">Prof. Kunle</a> and <a
          href="http://lampwww.epfl.ch/~odersky/">Prof. Odersky</a> supervision. The central themes of this thesis are
        sensor fusion and spatial, an hardware description language (Verilog is also one, but tedious).</p>
      <p>This part is about scala-flow, a simulation library with a spatial-lang integration written to ease the
        prototyping, development and testing of applications that can be represented as data flows with some subpart
        going through spatial written accelerators.</p>
      <h1 id="a-simulation-tool-for-data-flows-with-spatial-integration-scala-flow">A simulation tool for data flows
        with Spatial integration: scala-flow</h1>
      <h2 id="purpose">Purpose</h2>
      <p>Data flows are intuitive visual representations and abstractions of computation. As all forms of
        representations and abstractions, they ease complexity management, and let engineers reason at a higher level.
        They are common in the context of embedded systems, where sensors and electronic circuits have natural visual
        representations. They are also used in most forms of data processing, in particular those related to so called
        <em>big data</em>.</p>
      <p>Spark and Simulink are popular libraries for data processing and embedded systems, respectively. Spark grew
        popular as an alternative to Hadoop. The advantages of Spark over Hadoop was, among others, in-memory
        communication between nodes (as opposed to through files) and a functionally inspired scala api that brought
        better abstractions and reduced the number of lines of code. Less boilerplate and duplication of code improve
        abstraction and ease prototyping thanks to faster iteration.</p>
      <p>Simulink by MathWorks on the other hand, is a graphical programming environment for modeling, simulating and
        analyzing dynamic systems, including embedded systems. Its primary interface is a graphical block diagramming
        tool and a customizable set of block libraries.</p>
      <div class="figure">
        <img src="simulink.png" alt="An example of the simulink interface" />
        <p class="caption">An example of the simulink interface</p>
      </div>
      <p>scala-flow is inspired by both of these tools. It is general purpose in the sense that it can be used to
        represent any dynamic systems. Nevertheless, its primary intended use is to develop, prototype, and debug
        embedded systems, and in particular those that make use of spatially programmed hardware. scala-flow has a
        functional/composable api, displays the constructed graph and provides block constructions. It has strong type
        safety: the type of the input and output of each node is checked during compilation time to ensure the soundness
        of the resulting graph.</p>
      <h2 id="source-sink-and-transformations">Source, Sink and Transformations</h2>
      <p>Data are passed from nodes to nodes under the form of typed “packets” containing a value of the given type, an
        emission timestamp, and the delays the packet has encountered during its processing through the different nodes
        of the graph.</p>
      <p><code>case class Timestamped[A](t: Time, v: A, dt: Time)</code></p>
      <p>They are called Timestamped because they represent values and their corresponding timestamp information.</p>
      <p>Packets get emitted from <code>Source0[T]</code> (nodes with no input), processed and transformed by other
        nodes until they reach sinks (nodes with no output). Nodes are connected between each other according to the
        structure of the data flow.</p>
      <p>Nodes all mix-in the common trait <code>Node</code>. Every emitting <code>Node</code> (all nodes except sinks)
        mix-in the trait <code>Source[A]</code> whose type parameter <code>A</code> indicates the type of the packets
        emitted by this node. Indeed, nodes can only have one output but they can have any number of inputs. Every node
        also mixes-in the trait <code>SourceX[A, B, ...]</code> where X is the number of inputs for that node and is
        replaced by the actual arity (1, 2, 3, …). This is similar to <code>FunctionX[A, B, ..., R]</code>, the type of
        functions in scala.</p>
      <ul>
        <li><code>Source0</code> indicates that the node takes exactly 0 input.</li>
        <li><code>Source1[A]</code> indicates that the node has 1 input whose packets are of type A.</li>
        <li><code>Source2[A,B]</code> indicates that the nodes has 2 inputs whose packets are respectively of type
          <code>A</code> and <code>B</code></li>
        <li>etc …</li>
      </ul>
      <p>Since all nodes mix-in a <code>SourceX</code>, the compiler can check that the inputs of each node are of the
        right type.</p>
      <p>All <code>SourceX</code> must define <code>def listenI(x: A)</code> where <code>I</code> goes from 1 to X and
        <code>A</code> correspond to the corresponding type parameter of <code>SourceX</code>.
        <code>def listenI(x: A)</code> defines the action to take whenever a packet is received from the input I. Those
        functions are callbacks used to pass packets to the nodes following a listener pattern.</p>
      <p>There is a special case, <code>SourceN[A, R]</code> which represent nodes that have an *-arity of type
        <code>A</code> and emit packets of type <code>R</code>. For instance, the <code>Plot</code> nodes take * number
        of sources and display them all on the same plot. The only constraint is that all the source nodes must emit the
        same kind of data of type A. Otherwise, it would not make sense to compare them. For plots specifically,
        <code>A</code> also has a context bound of <code>Data</code> which means that there exists a conversion from
        <code>A</code> to a <code>Seq[Float]</code>, to ensure that <code>A</code> is displayable in a multiplot as time
        series. The x-axis, the time, correspond to the timestamp of emission contained in the packet.</p>
      <p>An intermediary node that applies a transformation mixs-in the trait <code>OpX[A, B, ..., R]</code> where
        <code>A, B</code> is the type of the input, and <code>R</code> is the type of the output.</p>
      <p><code>OpX[A, B, ..., R] extends SourceX[A, B, ...] with Source[R]</code>.</p>
      <p>For instance, <code>zip(sourceA, sourceB)</code> is an <code>Op[A, B, (A, B)]</code>. In most cases,
        <code>Op</code>s are a transformation of an incoming packet followed by a broadcasting (with the function
        <code>def broadcast(x: R)</code>) to the nodes that have for source this node.</p>
      <h2 id="demo">Demo</h2>
      <p>Below is the scala-flow code corresponding to a data-flow comparing a particle filter, an extended kalman
        filter, and the true state of the underlying model, the trajectory of the drone. At each tick of the different
        clocks, a packet containing the time as value is sent to a node simulating a sensor. Those sensors have access
        to the underlying model and transform the time into noisy sensor measurements, then forward them to the two
        filters. Once processed by the filters, the packets are plotted by the Plot sink. The plot also take as input
        the true state as given by the “toPoints” transformation.</p>
      <div class="sourceCode">
        <pre class="sourceCode scala"><code class="sourceCode scala">
  <span class="co">//****** Model ******</span>
  <span class="kw">val</span> dtIMU   = <span class="fl">0.01</span>
  <span class="kw">val</span> dtVicon = (dtIMU * <span class="dv">5</span>)

  <span class="kw">val</span> covAcc    = <span class="fl">1.0</span> 
  <span class="kw">val</span> covGyro   = <span class="fl">1.0</span> 
  <span class="kw">val</span> covViconP = <span class="fl">0.1</span> 
  <span class="kw">val</span> covViconQ = <span class="fl">0.1</span>

  <span class="kw">val</span> numberParticles = <span class="dv">1200</span>

  <span class="kw">val</span> clockIMU   = <span class="kw">new</span> <span class="fu">TrajectoryClock</span>(dtIMU)
  <span class="kw">val</span> clockVicon = <span class="kw">new</span> <span class="fu">TrajectoryClock</span>(dtVicon)

  <span class="kw">val</span> imu   = clockIMU.<span class="fu">map</span>(<span class="fu">IMU</span>(<span class="fu">eye</span>(<span class="dv">3</span>) * covAcc, <span class="fu">eye</span>(<span class="dv">3</span>) * covGyro, dtIMU))
  <span class="kw">val</span> vicon = clockVicon.<span class="fu">map</span>(<span class="fu">Vicon</span>(<span class="fu">eye</span>(<span class="dv">3</span>) * covViconP, <span class="fu">eye</span>(<span class="dv">3</span>) * covViconQ))

  <span class="kw">lazy</span> <span class="kw">val</span> pfilter = 
      <span class="fu">ParticleFilterVicon</span>(
        imu,
        vicon,
        numberParticles,
        covAcc,
        covGyro,
        covViconP,
        covViconQ
      )

  <span class="kw">lazy</span> <span class="kw">val</span> ekfilter = 
      <span class="fu">EKFVicon</span>(
        imu,
        vicon,
        covAcc,
        covGyro,
        covViconP,
        covViconQ
      )

  <span class="kw">val</span> filters = List(ekfilter, pfilter)

  <span class="kw">val</span> points = clockIMU.<span class="fu">map</span>(<span class="fu">LambdaWithModel</span>(
	(t: Time, traj: Trajectory) =&gt; traj.<span class="fu">getPoint</span>(t)), <span class="st">&quot;toPoints&quot;</span>)

  <span class="kw">val</span> pqs =  points.<span class="fu">map</span>(x =&gt; (x.<span class="fu">p</span>, x.<span class="fu">q</span>), <span class="st">&quot;toPandQ&quot;</span>)

  <span class="fu">Plot</span>(pqs, filters:_*)</code></pre>
      </div>
      <div class="figure">
        <img src="empty.jpg" alt="Example of a scala-flow program" />
        <p class="caption">Example of a scala-flow program</p>
      </div>
      <pre class="text" samepage="true"><code>         ┌────────────────────┐ ┌────────────────────┐
         │TrajectoryClock 0.01│ │TrajectoryClock 0.05│
         └─────┬────────────┬─┘ └────────┬───────────┘
               │            │            │            
               v            v            v            
           ┌───────┐   ┌────────┐   ┌─────────┐       
           │Map IMU│   │toPoints│   │Map Vicon│       
           └──┬──┬─┘   └────┬───┘   └───┬──┬──┘       
              │  │          │           │  │          
              │  │          │    ┌──────┘  │          
              │  └──────────┼────┼─────────┼┐         
              └───────────┐ │    │         ││         
             ┌────────────┼─┘    │         ││         
             │            │      │         ││         
             v            v      v         vv         
         ┌───────┐ ┌───────────────────┐ ┌────────┐   
         │toPandQ│ │     RBPFVicon     │ │EKFVicon│   
         └───┬───┘ └──────────┬────────┘ └────┬───┘   
             │                │               │       
             └──────────────┐ │ ┌─────────────┘       
                            │ │ │                     
                            v v v                     
                          ┌───────┐                   
                          │ Plot  │                   
                          └───────┘                  </code></pre>
      <div class="figure">
        <img src="empty.jpg" alt="Graph representation of the data-flow" />
        <p class="caption">Graph representation of the data-flow</p>
      </div>
      <h2 id="block">Block</h2>
      <p>A block is a node representing a group of nodes. That node can be summarized by its input and output such that
        from an external perspective, it can be considered as a simple node. Similar to the way an interface or an API
        hide its implementation details, a block hides its inner workings to the rest of the data-flow as long as the
        block receives and emits the right type of packets. This logic extends to the graphical representation. Blocks
        are represented as nodes in the high-level graph but expanded in an independent graph below the main one.</p>
      <p>Similar to <code>OpX[A, B, ..., R]</code> , there exists <code>BlockX[A, B, ..., R]</code> which all extend
        <code>Block[R]</code> and take X sources as input. All <code>Block[R]</code> must define an <code>out</code>
        method of the form: <code>def out: Source[R]</code>.</p>
      <p>For instance, the filters are blocks with the following signatures:</p>
      <div class="sourceCode">
        <pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">RBPFVicon</span>(rawSource1: Source[(Acceleration, Omega)],
                     rawSource2: Source[(Position, Attitude)],
                     N: Int,
                     covAcc: Real,
                     covGyro: Real,
                     covViconP: Real,
                     covViconQ: Real)	
	<span class="kw">extends</span> Block2[(Acceleration, Omega), 
		           (Position, Attitude),
				   (Position, Attitude)] {
	
		<span class="kw">def</span> imu = source1
		<span class="kw">def</span> vicon = source2
		
		<span class="kw">def</span> out = ...
	}</code></pre>
      </div>
      <div class="figure">
        <img src="empty.jpg" alt="Signature of the block of the particle filter" />
        <p class="caption">Signature of the block of the particle filter</p>
      </div>
      <p>and similar for EKFVicon.</p>
      <p>The careful reader might notice that the above block takes as arguments <code>rawSourceI</code> and not
        <code>sourceI</code> directly. However, the packets are processing in the body of the class as incoming from
        <code>sourceI</code> (<code>def imu = source1</code>). This is a consequence of intermediary <code>Source</code>
        potentially needing to be generated during the graph creation to synchronize multiple scheduler together. More
        details below.</p>
      <h2 id="graph-construction">Graph construction</h2>
      <p>A graph can be entirely re-evaluated multiple times. For instance, we might want to run our simulation more
        than once. A feature of scala-flow is that the nodes of a graph are immutable and can be reused between
        different evaluations. This enables us to serialize, store or transfer a graph easily. A graph is a data
        structure and scala-flow follows that intuition by separating the construction of graph and its evaluations.
        What is specific and shortlived for the lapse of time of an evaluation of a graph are the <code>Channel</code>s
        between the different nodes.</p>
      <h3 id="channel">Channel</h3>
      <p><code>Channel</code>s are specific to a particular node and a particular “channel” of a node. A “channel” here
        refers to the actual I from <code>listenI(packet)</code> of a node to call. When the graph is initialized, the
        channels are created according to the graph structure.</p>
      <p>If we take a look at <code>Channel2</code> for instance:</p>
      <div class="sourceCode">
        <pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Channel[A] {
  <span class="kw">def</span> <span class="fu">push</span>(x: Timestamped[A], dt: Time): Unit
}

...

<span class="kw">case</span> <span class="kw">class</span> Channel2[A](receiver: Source2[_, A], scheduler: Scheduler)
    <span class="kw">extends</span> Channel[A] {
  <span class="kw">def</span> <span class="fu">push</span>(x: Timestamped[A], dt: Time = <span class="dv">0</span>) = 
	...
}</code></pre>
      </div>
      <p>We see that it requires that the receiver is a <code>Source2</code>. This actually means that the receiver must
        have <strong>at least</strong> (and not exactly) 2 sources. This is a consequence of<code>SourceI+1</code>
        extending <code>SourceI</code>, the base case being <code>Source0</code>:
        <code>trait Source2[A, B] extends Source1[A]</code>.</p>
      <p>Now, if we look at the private method <code>broadcast</code> inside <code>Source[T]</code></p>
      <div class="sourceCode">
        <pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">def</span> <span class="fu">broadcast</span>(x: =&gt; Timestamped[A], t: Time = <span class="dv">0</span>) =
    <span class="kw">if</span> (!closed)
      channels.<span class="fu">foreach</span>(_.<span class="fu">push</span>(x, t))</code></pre>
      </div>
      <p>We see that <code>broadcast</code> is simply pushing elements into all its private channels. The channels are
        set during initialization of the graph in a simple manner: The graph is traversed and for all node the
        corresponding channel are created for its corresponding sources.</p>
      <h2 id="buffer-and-cycles">Buffer and cycles</h2>
      <p>It is possible to create cycles inside data-flows at the express condition that the immediate node creating a
        cycle is exclusively a kind of node called <code>Buffer</code>. Buffers relay to the next node any incoming data
        but with the particularity of a buffering of one packet. <code>Buffer</code>s are created with an initial value.
        When the first packet arrives, the Buffer stores the incoming packet and broadcast the initial value. When
        another following packet arrives, the buffer stores the new packet and broadcast the previously stored one and
        so on.</p>
      <p>Even using buffer nodes, declaring cycle requires additional steps:</p>
      <div class="sourceCode">
        <pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> source: Source[A] = ...
<span class="kw">val</span> buffer = Buffer(merge, initA)
<span class="kw">val</span> zipped = source.<span class="fu">zip</span>(buffer)</code></pre>
      </div>
      <p>This will not be valid scala because there is a circular dependency between buffer and zipped. Indeed,
        instantiating <code>buffer</code> require to instantiate <code>zipped</code>, which require to instantiate
        <code>buffer</code> … A solution is to use <code>lazy val</code>.</p>
      <div class="sourceCode">
        <pre
          class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> source: Source[A] = ...
<span class="kw">lazy</span> <span class="kw">val</span> buffer = Buffer(merge, initA)
<span class="kw">lazy</span> <span class="kw">val</span> zipped = source.<span class="fu">zip</span>(buffer)</code></pre>
      </div>
      <p><code>lazy val a = e</code> in scala implements lazy evaluation, meaning the expression <code>e</code> is not
        evaluated until it is needed. In our case, this makes sure that both <code>buffer</code> and <code>zipped</code>
        can be declared and instantiated. It is enough that their parameters are declared of the right type, they do not
        actually need to evaluated. At the initialization of the entire graph, there is no circular dependency either
        because both instances exist and will only be used during the evaluation of the graph.</p>
      <h2 id="source-api">Source API</h2>
      <p>Here is a simplified description of the API of each source.</p>
      <p>When relevant, the functions have an alternative <code>methodNameT</code> function that takes themselves
        function whose domain is <code>Timestamped[A]</code> instead of <code>A</code>.</p>
      <p>For instance, there is a</p>
      <p><code>def foreachT(f: Timestamped[A] =&gt; Unit): Source[A]</code></p>
      <p>which is equivalent to the <code>foreach</code> below except it can access the additional fields <code>t</code>
        and <code>dt</code> in <code>Timestamped</code></p>
      <div class="sourceCode">
        <pre class="sourceCode scala"><code class="sourceCode scala">
<span class="kw">trait</span> Source[A] {

  <span class="co">/** return a new source that map every incoming packet by the function f </span>
<span class="co">    * such that new packets are Timestamped[B] </span>
<span class="co">    */</span>
  <span class="kw">def</span> map[B](f: A =&gt; B): Source[B]

  <span class="co">/** return a filtered source that only broadcast</span>
<span class="co">    *  the elements that satisfy the predicate b */</span>
  <span class="kw">def</span> <span class="fu">filter</span>(b: A =&gt; Boolean): Source[A]

  <span class="co">/** return this source and apply the function f to each</span>
<span class="co">    *  incoming packets as soon as they are received </span>
<span class="co">    */</span>
  <span class="kw">def</span> <span class="fu">foreach</span>(f: A =&gt; Unit): Source[A]
  
  <span class="co">/** return a new source that broadcast elements</span>
<span class="co">    * until the first time the predicate b is not satisfied</span>
<span class="co">    */</span>
  <span class="kw">def</span> <span class="fu">takeWhile</span>(b: A =&gt; Boolean): Source[A]  
  
  <span class="co">/** return a new source that accumulate As into a List[A]</span>
<span class="co">    * then broadcast it when the next packet from the other </span>
<span class="co">    * source clock is received </span>
<span class="co">    */</span>
  <span class="kw">def</span> <span class="fu">accumulate</span>(clock: Source[Time]): Source[ListT[A]]
    
  <span class="co">/** return a new source that broadcast all element inside the collection</span>
<span class="co">    * returned by the application of f to all incoming packet</span>
<span class="co">    */</span>
  <span class="kw">def</span> flatMap[C](f: A =&gt; List[C]): Source[C]
 
  <span class="co">/** assumes that A is a List[Timestamped[B]]. </span>
<span class="co">    * returns a new source that apply the reduce function </span>
<span class="co">    * over the collection contained in every incoming packet */</span>
  <span class="kw">def</span> reduce[B](default: B, f: (B, B) =&gt; B)
      (<span class="kw">implicit</span> ev: A &lt;:&lt; ListT[B]): Source[B]
	  
  <span class="co">/** return a new source that broadcast pair of the packet from this source </span>
<span class="co">    * and the source provided as argument. Wait until a packet is received </span>
<span class="co">    * from both source. Packets from both source are queued such </span>
<span class="co">    * that independant of the order, they are never discarded</span>
<span class="co">    * A2 B1 A3 B2 B3 B4 B5 A4=&gt; (A1, B1), (A2, B2), (A3, B3), (A4, B4),</span>
<span class="co">	* [Queue[B5]]</span>
<span class="co">    */</span>
  <span class="kw">def</span> zip[B](s2: Source[B]): Source[Boolean]


  <span class="co">/** return a new source that broadcast pair of the packet from this source </span>
<span class="co">    * and the source provided as argument. Similar to zip except that </span>
<span class="co">	* if multiple packets from the source provided as argument is received</span>
<span class="co">	* before, all except the last get discarded.</span>
<span class="co">    * A2 B1 A3 B2 B3 B4 B5 A4=&gt; (A1, B1), (A2, B2), (A3, B3), (A4, B4),</span>
<span class="co">	* [Queue[B5]]</span>
<span class="co">    */</span>
  <span class="kw">def</span> zipLastRight[B](s2: Source[B])

  
  <span class="co">/** return a new source that broadcast pair of the packet from this source </span>
<span class="co">    * and the source provided as argument. Similar to zip except that all </span>
<span class="co">	* packet except the last get discarded when both source are not in sync.</span>
<span class="co">    * A1 A2 B1 A3 B2 B3 A4=&gt; (A1, B1), (A3, B2), (B3, A4)</span>
<span class="co">    */</span>  
  <span class="kw">def</span> zipLast[B](s2: Source[B])

  <span class="co">/** return a new source that combine this source and the provided source .</span>
<span class="co">    * packets from this source are Left</span>
<span class="co">    * packets from the other source are Right</span>
<span class="co">    */</span>
  <span class="kw">def</span> merge[B](s2: Source[B]): Source[Either[A, B]]
  
  <span class="co">/** return a new source that fuse this source and the provided source</span>
<span class="co">    * as long they have the same type.</span>
<span class="co">    * any outgoing packet is indistinguishable of origin</span>
<span class="co">    */</span>  
  <span class="kw">def</span> <span class="fu">fusion</span>(sources: Source[A]*): Source[A]	  

  <span class="co">/** &quot;label&quot; every packet by the group returned by f */</span>  
  <span class="kw">def</span> groupBy[B](f: A =&gt; B): Source[(B, A)]

  <span class="co">/** print every incoming packet */</span>
  <span class="kw">def</span> <span class="fu">debug</span>(): Source[A]

  <span class="co">/** return a new source that buffer 1 element and </span>
<span class="co">    * broadcast the buffered element with the time of the incoming A </span>
<span class="co">    */</span>
  <span class="kw">def</span> <span class="fu">bufferWithTime</span>(init: A): Source[A] 
  
  <span class="co">/** return a new source that do NOT broadcast any element */</span>
  <span class="kw">def</span> muted: Source[A]

  <span class="co">/** return a new source that broadcast one incoming packet every </span>
<span class="co">    * n incoming packet.</span>
<span class="co">    * The first broadcasted packet is the nth received one</span>
<span class="co">    */</span>
  <span class="kw">def</span> <span class="fu">divider</span>(n: Int): Source[A]

  <span class="co">/** return a pair of source from a source of pair */</span>
  <span class="kw">def</span> unzip2[B, C](<span class="kw">implicit</span> ev: A &lt;:&lt; (B, C)): (Source[B], Source[C])
  
  <span class="co">/** return a new source whose every outgoing packet have an added dt</span>
<span class="co">    * in their delay component</span>
<span class="co">    */</span>
  <span class="kw">def</span> <span class="fu">latency</span>(dt: Time): Source[A]

  <span class="co">/** return a new source whose broadcasted packets contain the time of </span>
<span class="co">    * emission</span>
<span class="co">    */</span>
  <span class="kw">def</span> toTime: Source[Time]

  <span class="co">/** return a new source that do NOT broadcast the first n packets */</span>
  <span class="kw">def</span> <span class="fu">drop</span>(n: Int): Source[A]
}


<span class="kw">implicit</span> <span class="kw">class</span> <span class="fu">TimeSource</span>(source: Source[Time]) {

  <span class="co">/** stop the broadcasting after the timeframe tf has elapsed */</span>
  <span class="kw">def</span> <span class="fu">stop</span>(tf: Timeframe): Source[Time]

  <span class="co">/** add a random delay following a gaussian with corresponding </span>
<span class="co">    * mean and variance */</span>
  <span class="kw">def</span> <span class="fu">latencyVariance</span>(mean: Real, variance: Real): Source[Time]

  <span class="co">/** add a delay of dt */</span>
  <span class="kw">def</span> <span class="fu">latency</span>(dt: Time): Source[Time]

  <span class="co">/** return a new source of the difference of time between </span>
<span class="co">    * the two last emitted packets */</span>
  <span class="kw">def</span> <span class="fu">deltaTime</span>(init: Time = <span class="fl">0.0</span>): Source[Time]
  
}</code></pre>
      </div>
      <div class="figure">
        <img src="empty.jpg" alt="API of the Sources" />
        <p class="caption">API of the Sources</p>
      </div>
      <p>The real API also includes <code>name</code> and <code>silent</code> parameters. Both are only relevant for the
        graphical representation. The name of the block will be overriden by name if present and the node will be
        skipped in the graphical representation if silent is present.</p>
      <h2 id="batteries">Batteries</h2>
      <p>The following nodes are already included and pre-defined:</p>
      <ul>
        <li><code>Clock</code>: <code>Source0[Time]</code> that takes as parameter a timeframe <code>dt</code> which
          corresponds to the lapse of time between each emission of packets. The packets contain as values the time of
          emission.</li>
        <li>
          <p><code>TestTS</code>: “Test Time Series” Sink that takes a source of labeled data. Labeled data are data
            joined with their corresponding label. This sink displays the mean error, the max error error across all
            datapoints and also the RMSE.</p>
          <pre class="text"><code>[info ParticleFi ] RMSE       : 1.099241e-01, 4.213478e-03
[info ParticleFi ] Mean errors: 3.026816e-01, 4.746430e-02
[info ParticleFi ] Max  errors: 7.086643e-01, 2.386466e-01</code></pre>
        </li>
        <li>
          <p><code>Plot</code>: Sink that displays the time series under the form of a plot. Can take an arbitrary
            number of time series, each of arbitrary dimension. In the example below, 5 time series of 2 dimensions are
            plotted. The plotting library is the one included in <a
              href="https://github.com/scalanlp/breeze">scala-breeze</a>, used elsewhere for matrix and vector
            operations.</p>
        </li>
      </ul>
      <div class="figure">
        <img src="ex-plot.png" alt="Example of a plot generated by the Plot sink" />
        <p class="caption">Example of a plot generated by the Plot sink</p>
      </div>
      <ul>
        <li><code>Jzy3dTrajectoryVisualisation</code>: Sink. It displays a point following a trajectory in a new window.
          takes a source of points as source. An example as shown in Part I.</li>
      </ul>
      <video autoplay loop>
        <source src="flight.webm" type="video/webm">
      </video>
      <div class="figure">
        <embed src="flight.webm" width="400" />
        <p class="caption">Example of a trajectory visualization</p>
      </div>
      <p>In addition, any <code>scala.Stream[A]</code> can be transformed into a <code>Source0</code> node using
        <code>EmitterStream[A]</code> with <code>A</code> being the type of the <code>Stream</code>. This is how
        <code>Clock</code> is implemented, as an infinite scala stream of Time.</p>
      <h2 id="batch">Batch</h2>
      <p>A batch is a node that processes its inputs in “batch” mode. All the other nodes process their inputs in
        “stream” mode. By “stream” mode, it is meant that the node processes the inputs one-by-one, as soon as they
        arrive. On the other hand, the “batch” mode means that the node processes the incoming packets once they have
        all arrived, once and for all. This is the case for most sinks (for example, it makes more sense for a plot to
        build it once all the data is arrived).</p>
      <p>Spatial is a language described in part IV and developed to write high-level hardware design of accelerators. A
        spatial application can be integrated into scala-flow as a transformation node using the streaming interface of
        Spatial. Spatial applications can only run during the same runtime than scala-flow using the interpreter
        described in Part III and originally developed for this exact purpose. Batches are essential to Spatial
        integration: the nodes that simulate a Spatial application can only run and treat all the data at once. Indeed,
        running a Spatial application involves running the Spatial compiler in the background and compiling the full
        meta-program, including all meta-constant values.</p>
      <h2 id="scheduler">Scheduler</h2>
      <p>Scheduling is the core mechanism of scala-flow. Scheduling ensures that packets get emitted by the sending
        nodes and received by the recipient nodes at the “right time”. Since scala-flow is a simulation tool, the
        “scala-flow time” does not correspond at all to the real time. Scheduling emits the packets as fast as it can.
        Therefore, since time is an arbitrary component of the packet, the only constraint that scheduling must satisfy
        is emitting the packets from all nodes in the right order.</p>
      <p>Scheduling is achieved by one or many Schedulers. Schedulers are essentially priority queues of actions. The
        priority is the timestamp plus the accumulated delay of the packet. The actions are side-effect functions that
        emit packets to the right node by the intermediary of channels. Every node has a scheduler and enqueue action to
        it every time the <code>broadcast</code> method is called. The scheduler are propagated through the graph
        through two rules:</p>
      <ul>
        <li>Every <code>Source0</code> has for <code>Scheduler</code> the “main scheduler” available globally passed on
          as an implicit parameter</li>
        <li>Other nodes either explicitly create their own scheduler (like the batch nodes) or use the Scheduler from
          their <code>source1</code> input.</li>
      </ul>
      <p>Only one scheduler executes actions at the same time. When a scheduler is finished, another one is started
        unless it was the last one. In practice, when a scheduler has no more packets to handle, there is a callback to
        <code>CloseListener</code> nodes and scheduler according to their <code>CloseListener</code> priority. Batches
        have their own scheduler and are also among <code>CloseListener</code> of the <code>Scheduler</code> of their
        source node, waiting for them to all finish. Batches process the accumulated packets as soon as the
        <code>CloseListener</code> callback is called.</p>
      <p>All schedulers start at time 0. The current time of a scheduler is the time of the last emitted packet.
        <code>Scheduler</code> can en-queue new actions while the scheduler is “live” but the en-queued packet can only
        have a time of emission greater or equal to the current time. In the trivial case where there is no Batch, only
        one scheduler is needed.</p>
      <h2 id="replay">Replay</h2>
      <p><code>Replay</code> are nodes at the frontier of two schedulers. They accumulate packets from the actions of
        the first scheduler until they receive its <code>CloseListener</code> callback. When received, they en-queue all
        the accumulated actions into the second scheduler. <code>Replay</code>s are the primary mechanisms of
        synchronization between two <code>Scheduler</code>s. A <code>Batch</code> is essentially a <code>Replay</code>
        with its own <code>Scheduler</code> as secondary <code>Scheduler</code>. However, a batch transforms the data
        before broadcasting instead of simply replaying it.</p>
      <p><strong>All sources of a node must share the same scheduler. Replays are automatically inserted to ensure that
          this rule is respected</strong></p>
      <p>The automatic insertion is the reason why nodes must define all <code>rawSourceI</code> but one should only
        externally ever use the <code>sourceI</code> methods. In most case, <code>rawSourceI</code> and
        <code>sourceI</code> are by definition the same. However, if a replay node has to be created, it is inserted
        in-between <code>rawSourceI</code> and <code>sourceI</code>.</p>
      <h2 id="multi-scheduler-graph">Multi-Scheduler graph</h2>
      <p>When the graph involves multiple schedulers, depending on the graph structure, the synchronization between them
        might require additional replays.</p>
      <div>
        <!-- htmlmin:ignore -->
        <div class="mermaid">
          graph LR
          subgraph scheduler 1
          sA(sourceA)
          sB(sourceB)
          sC(sourceC)
          end
          subgraph scheduler2
          node(Node)
          rest(...)
          end
          sA--&gt;node
          sB--&gt;node
          sC--&gt;node
          node--&gt;rest
        </div>
        <!-- htmlmin:ignore -->
      </div>
      <div class="figure">
        <img src="empty.jpg" alt="Node’s sources sharing the same Scheduler" />
        <p class="caption">Node’s sources sharing the same Scheduler</p>
      </div>
      <p>In the above structure, no replay need to be created because all sources of the node “Node” share the same
        scheduler. It suffices to wait for the closing callback of that scheduler.</p>
      <div>
        <!-- htmlmin:ignore -->
        <div class="mermaid">
          graph LR
          subgraph scheduler 1
          sA(sourceA)
          end
          subgraph scheduler 2
          sB(sourceB)
          end
          subgraph scheduler 3
          sC(sourceC)
          end
          subgraph scheduler 4
          node(Node)
          rest(...)
          end
          sA--&gt;node
          sB--&gt;node
          sC--&gt;node
          node--&gt;rest
        </div>
        <!-- htmlmin:ignore -->
      </div>
      <div class="figure">
        <img src="empty.jpg" alt="Node’s sources not sharing the same Scheduler" />
        <p class="caption">Node’s sources not sharing the same Scheduler</p>
      </div>
      <p>In the above structure, intermediary replays must be created so that the node “Node” sources share the same
        scheduler.</p>
      <div>
        <!-- htmlmin:ignore -->
        <div class="mermaid">
          graph LR
          subgraph scheduler 1
          sA(sourceA)
          end
          subgraph scheduler 2
          sB(sourceB)
          end
          subgraph scheduler 3
          sC(sourceC)
          end
          subgraph scheduler 4
          replay1(Replay1)
          replay2(Replay2)
          replay3(Replay3)
          end
          subgraph scheduler 5
          node(Node)
          rest(...)
          end
          sA--&gt;replay1
          sB--&gt;replay2
          sC--&gt;replay3
          replay1--&gt;node
          replay2--&gt;node
          replay3--&gt;node
          node--&gt;rest
        </div>
        <!-- htmlmin:ignore -->
      </div>
      <div class="figure">
        <img src="empty.jpg" alt="Example of Replays between inserted in-between a Node and its sources" />
        <p class="caption">Example of Replays between inserted in-between a Node and its sources</p>
      </div>
      <h2 id="inithook">InitHook</h2>
      <p>Some nodes need initialization values for each simulation evaluation. For instance, this is the case for the
        trajectory filters: the filters require to be given the initial position and attitude of the drone. An
        <code>InitHook[I]</code> is an implicit parameter passed to the nodes during their declaration. The type
        parameter <code>I</code> is the type of the values that will be accessible by the nodes as initialization
        values.</p>
      <h2 id="modelhook">ModelHook</h2>
      <p>Similarly, some nodes need access to a “Model”. A “Model” is specific to a simulation and is an oracle that a
        node might need to consult in order to generate data or get any other information about the external simulation
        environment. For instance, the sensor nodes generate noisy measurements as a function of the time based on the
        underlying trajectory model. Similar to <code>InitHook[I]</code>, it is passed to nodes during the graph
        declaration as an implicit parameter.</p>
      <h2 id="nodehook">NodeHook</h2>
      <p>To gather the nodes and their connection between each others, a <code>NodeHook</code> is used. Every node must
        have access to a <code>NodeHook</code> to add itself to the registry. For nodes that take no input, the
        <code>Source0</code>, the <code>NodeHook</code> is passed as an implicit parameter. For any other nodes, the
        <code>NodeHook</code> is propagated through the graph. All others nodes use the <code>NodeHook</code> from their
        <code>source1</code>. This is similar to the way <code>Scheduler</code> are propagated through the graph.</p>
      <h2 id="graphical-representation">Graphical representation</h2>
      <p>The graphical representation is a graph in the <code>ASCII</code> format. The library <a
          href="https://github.com/mdr/ascii-graphs">ascii-graphs</a> is used to generate the output in
        <code>ASCII</code> from sets of vertices and edges. The set of vertices and edges is retrieved from the set of
        nodes contained in <code>NodeHook</code> and their sources.</p>
      <h2 id="flowapp">FlowApp</h2>
      <p>A <code>FlowApp[M, I]</code> is an extension of the scala <code>App</code>, a trait that treats the inner
        declaration of an object as a main program function. Its type parameters correspond respectively to the type
        parameter of <code>ModelHook[M]</code> and <code>InitHook[I]</code>. A <code>FlowApp</code> has the methods
        <code>drawExpandedGraph()</code> which display the <code>ASCII</code> representation of the graph and the method
        <code>run(model, init)</code> which run the evaluation of the simulation with the given model and initialization
        value.</p>
      <h2 id="spatial-integration">Spatial integration</h2>
      <p>Scala-flow can also be used as a complementary tool for the development of applications embedding Spatial, a
        language to design hardware accelerators. Accelerators can be easily represented as simple transformation nodes
        in a data flow and hence as a regular <code>OpX</code> node in scala-flow.</p>
      <p><code>SpatialBatch</code> and its variants are the nodes used to embed spatial applications.
        <code>SpatialBatchRawX</code>s run a user-defined application. The application can use the list of incoming
        packets as a constant list of values. X is the number of sources of the node. <code>SpatialBatchX</code>s are
        specialized <code>SpatialBatchRawX</code>s with additional syntactic sugar such that there is no more
        boilerplate and the required code is reduced to the most essential to write stream processing Spatial
        applications. It is only to define a function <code>def spatial(x: TSA): SR</code> where <code>TSA</code> is a
        struct containing a value <code>v</code> of type <code>SA</code> (see below) and the packet timestamp as
        <code>t</code>.</p>
      <p>If we take a look at <code>SpatialBatch1</code>’s signature,</p>
      <div class="sourceCode">
        <pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">abstract</span> <span class="kw">class</span> SpatialBatch1[A, R, SA: Bits: Type, SR: Bits: Type]
	(<span class="kw">val</span> rawSource1: Source[A])
	(<span class="kw">implicit</span> <span class="kw">val</span> sa: Spatialable[A] { <span class="kw">type</span> Spatial = SA },
			  <span class="kw">val</span> sr: Spatialable[R] { <span class="kw">type</span> Spatial = SR }
	)</code></pre>
      </div>
      <p>we see that it takes type parameter <code>A, R, SA, SR</code> and the typeclass instances of
        <code>Spatialable</code> for <code>SA</code> and <code>SR</code>. <code>A</code> and <code>R</code> are the type
        members representing respectively the incoming and outgoing packet type. <code>SA</code> and <code>SR</code> are
        the spatial type into what they are converted to such that they can be handled by a spatial DSL. Indeed,
        <code>scala.Double</code> and <code>spatial.Double</code> are not the same type. The latter is a staged type
        part of the spatial DSL.</p>
      <p><code>Spatialable[A]</code> is a typeclass that declare a conversion from <code>A</code> to a Spatial type
        (declared as the inner type member <code>Spatial</code> of <code>Spatialable</code>.</p>
      <p>There exists a <code>Spatialable[Time]</code> which make the following example possible:</p>
      <div class="sourceCode">
        <pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">val</span> clock1 = <span class="kw">new</span> <span class="fu">Clock</span>(<span class="fl">0.1</span>).<span class="fu">stop</span>(<span class="dv">10</span>)
  <span class="kw">val</span> clock2 = <span class="kw">new</span> <span class="fu">Clock</span>(<span class="fl">0.1</span>).<span class="fu">stop</span>(<span class="dv">10</span>)  

  <span class="kw">val</span> spatial = <span class="kw">new</span> SpatialBatch1[Time, Time, Double, Double](clock1) {
    <span class="kw">def</span> <span class="fu">spatial</span>(x: TSA) = {
      <span class="fu">cos</span>(x.<span class="fu">v</span>)
    }    
  }

  <span class="kw">val</span> spatial2 = <span class="kw">new</span> SpatialBatch1[Time, Time, Double, Double](clock2) {
    <span class="kw">def</span> <span class="fu">spatial</span>(x: TSA) = {
      x.<span class="fu">v</span> + <span class="dv">42</span>
    }    
  }


  <span class="kw">val</span> spatial3 = <span class="kw">new</span> SpatialBatch2[Time, Time, Time, Double, Double, Double]
	                              (spatial, spatial2) {
    <span class="kw">def</span> <span class="fu">spatial</span>(x: Either[TSA, TSB]) = {
      x <span class="kw">match</span> {
        <span class="kw">case</span> <span class="fu">Right</span>(t) =&gt; t.<span class="fu">v</span><span class="dv">+10</span>
        <span class="kw">case</span> <span class="fu">Left</span>(t) =&gt; t.<span class="fu">v</span><span class="dv">-10</span>
      }
    }    
  }

  <span class="fu">Plot</span>(spatial3)</code></pre>
      </div>
      <div class="figure">
        <img src="empty.jpg" alt="Usage demonstration of spatial batches" />
        <p class="caption">Usage demonstration of spatial batches</p>
      </div>
      <p>Even though it looks inconspicuous, the <code>cos</code>, <code>+</code>, <code>-</code> functions are actually
        functions from the Spatial DSL. This simple scala-flow program actually compiles and runs through the
        interpreter 3 different Spatial programs.</p>
      <p>The development of an interpreter was required so that Spatial applications could run on the same runtime than
        scala-flow. The interpreter development is detailed in the next part of this thesis.</p>
      <h2 id="conclusion">Conclusion</h2>
      <p><code>scala-flow</code> is a modern framework to simulate, develop, prototype and debug applications which have
        a natural representation as data-flows. Its integration with Spatial makes it a good tool to include with
        Spatial to ease the development complex applications whenever the accelerated application needs to be written
        over multiple iterations of increasing complexity, and tested on different scenarios with modelable
        environments.</p>
      <h2 id="part-iii">Part III</h2>
      <p><a href="../../posts/th3/2017-08-16-thesis-part-3.html">Continue here to read the section about an interpreter
          for Spatial (III/IV)</a></p>
      <div id="refs" class="references">

      </div>
    </div>
    <div class="license" style="margin-left:80%;">
      <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Licence Creative Commons"
          style="border-width:0" src="../../images/cc.png" /></a>
    </div>
  </div>

  <hr>

  <div id="footer">
    <section class="social">
      <a href="https://ch.linkedin.com/in/rubenfiszel" target="_blank"><i class="fa fa-linkedin fa-2x"></i></a>
      <a href="https://github.com/rubenfiszel" target="_blank"><i class="fa fa-github fa-2x"></i></a>
      <a href="mailto:ruben@rubenfiszel.com"><i class="fa fa-envelope fa-2x"></i></a>
      <a href="assets/RubenFiszel_resume.pdf"><i class="fa fa-file fa-2x"></i></a>
    </section>
  </div>

  <script src="../../js/mermaid.min.js"></script>
  <script>mermaid.initialize({startOnLoad:true});</script>

  <script>
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-3040887-4', 'auto');
    ga('send', 'pageview');

  </script>
</body>

</html>
